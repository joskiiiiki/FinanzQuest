CREATE EXTENSION IF NOT EXISTS timescaledb;

-- Auth
CREATE ROLE auth_admin NOINHERIT LOGIN PASSWORD 'auth';
CREATE SCHEMA IF NOT EXISTS auth AUTHORIZATION auth_admin;

GRANT CREATE ON DATABASE postgres TO auth_admin;

ALTER USER auth_admin SET search_path = auth;

-- CREATE SCHEMA;
CREATE SCHEMA api;

-- tables
CREATE TYPE AssetType AS ENUM (
  'commodity',
  'crypto',
  'fund',
  'stock'
);

CREATE TABLE IF NOT EXISTS api.assets (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  symbol text NOT NULL,
  name text NOT NULL,
  description text,
  asset_type AssetType NOT NULL,
  last_updated date,
  CONSTRAINT AssetInfo_pkey PRIMARY KEY (id),
  CONSTRAINT AssetInfo_unique_symbol UNIQUE (symbol)
);

CREATE INDEX idx_asset_symbol ON api.assets USING HASH (symbol);

CREATE TABLE api.asset_prices (
  asset_id bigint NOT NULL,
  tstamp date NOT NULL,
  open REAL,
  close REAL,
  high real,
  low real,
  volume bigint,
  CONSTRAINT AssetPrices_pkey PRIMARY KEY (asset_id, tstamp),
  CONSTRAINT AssetPrices_asset_id_fkey FOREIGN KEY (asset_id) REFERENCES api.assets (id)
);

SELECT create_hypertable(
    'api.asset_prices',
    'tstamp',
    if_not_exists => true,
    migrate_data => true  -- keeps existing data
);

CREATE INDEX IF NOT EXISTS idx_asset_id ON api.asset_prices (asset_id);

CREATE INDEX IF NOT EXISTS idx_tstamp ON api.asset_prices (tstamp);


CREATE MATERIALIZED VIEW api.asset_prices_weekly
WITH (timescaledb.continuous) AS
SELECT
    d.asset_id,
    time_bucket(INTERVAL '1 week', d.tstamp) AS tstamp,      -- output column
    FIRST(d.open, d.tstamp) AS open,
    MAX(d.high) AS high,
    MIN(d.low) AS low,
    LAST(d.close, d.tstamp) AS close,
    SUM(d.volume) AS volume
FROM api.asset_prices d  -- ‚Üê alias 'd' for daily source
GROUP BY d.asset_id, time_bucket(INTERVAL '1 week', d.tstamp);


-- DEPOTS
CREATE SCHEMA depots;

CREATE TABLE IF NOT EXISTS depots.depots (
  created timestamp NOT NULL,
  cash bigint NOT NULL,
  cash_start bigint NOT NULL,
  users uuid[] NOT NULL,
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  CONSTRAINT Depots_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS depots.positions (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  asset_id bigint NOT NULL,
  amount real NOT NULL,
  price real NOT NULL,
  worth real NOT NULL,
  last DATE,
  depot_id bigint NOT NULL,
  CONSTRAINT Positions_pkey PRIMARY KEY (id),
  CONSTRAINT unique_depot_asset UNIQUE (depot_id, asset_id),
  CONSTRAINT Positions_asset_pkey FOREIGN KEY (asset_id) REFERENCES api.assets (id),
  CONSTRAINT Positions_depot_pkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_position_asset_depot ON depots.positions (asset_id, depot_id);

CREATE INDEX IF NOT EXISTS idx_position_asset ON depots.positions (asset_id);

CREATE INDEX IF NOT EXISTS idx_position_depot ON depots.positions (depot_id);

CREATE TABLE IF NOT EXISTS depots.transactions (
  depot_id bigint NOT NULL,
  user_id uuid,
  asset_id bigint NOT NULL,
  amount real NOT NULL,
  price real NOT NULL,
  tstamp timestamp NOT NULL DEFAULT NOW(),
  commission real NOT NULL,
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  CONSTRAINT Transactions_pkey PRIMARY KEY (id),
  CONSTRAINT Transactions_depot_fkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id) ON DELETE CASCADE,
  CONSTRAINT Transactions_stock_fkey FOREIGN KEY (asset_id) REFERENCES api.assets (id)
);

CREATE INDEX IF NOT EXISTS idx_transaction_assets_depot ON depots.transactions (asset_id, depot_id);

CREATE INDEX IF NOT EXISTS idx_transaction_asset ON depots.transactions (asset_id);

CREATE INDEX IF NOT EXISTS idx_transaction_depot ON depots.transactions (depot_id);

CREATE OR REPLACE VIEW depots.aggregated_transactions AS
WITH daily_totals AS (
  SELECT
    depot_id,
    asset_id,
    date(tstamp) AS tstamp,
    SUM(amount * price) AS daily_expenses,
    SUM(amount) AS daily_amount,
    SUM(commission) AS daily_commission
  FROM depots.transactions
  GROUP BY depot_id, asset_id, date(tstamp)
)
SELECT
  depot_id,
  asset_id,
  tstamp,
  daily_amount,
  daily_commission,
  SUM(daily_expenses) OVER (PARTITION BY depot_id, asset_id ORDER BY tstamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_expenses,
  SUM(daily_amount) OVER (PARTITION BY depot_id, asset_id ORDER BY tstamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_amount,
  SUM(daily_commission) OVER (PARTITION BY depot_id, asset_id ORDER BY tstamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_commission
FROM daily_totals
ORDER BY depot_id, asset_id, tstamp;

CREATE INDEX IF NOT EXISTS idx_transactions_depot_asset_date 
  ON depots.transactions (depot_id, asset_id, (tstamp::date));


CREATE OR REPLACE VIEW depots.position_values AS
WITH depot_first_transaction AS (
  SELECT depot_id, MIN(tstamp::date) as first_date
  FROM depots.transactions
  GROUP BY depot_id
),
depot_assets AS (
  SELECT DISTINCT depot_id, asset_id
  FROM depots.transactions
),
date_range AS (
  SELECT 
    da.depot_id,
    da.asset_id,
    generate_series(dft.first_date, CURRENT_DATE, '1 day'::interval)::date AS tstamp
  FROM depot_assets da
  JOIN depot_first_transaction dft ON da.depot_id = dft.depot_id
)
SELECT
  dr.depot_id,
  dr.tstamp,
  dr.asset_id,
  t.running_amount,
  t.running_commission,
  t.running_expenses,
  ap.close AS price,
  t.running_amount * ap.close AS market_value,
  (t.running_amount * ap.close) - t.running_expenses - t.running_commission AS position_profit
FROM date_range dr
INNER JOIN LATERAL (
  SELECT running_amount, running_commission, running_expenses
  FROM depots.aggregated_transactions t
  WHERE t.depot_id = dr.depot_id
    AND t.asset_id = dr.asset_id
    AND t.tstamp <= dr.tstamp
  ORDER BY t.tstamp DESC
  LIMIT 1
) t ON TRUE
LEFT JOIN LATERAL (
  SELECT close
  FROM api.asset_prices
  WHERE asset_id = dr.asset_id
    AND tstamp <= dr.tstamp
  ORDER BY tstamp DESC
  LIMIT 1
) ap ON TRUE
WHERE ap.close IS NOT NULL
ORDER BY dr.depot_id, dr.tstamp, dr.asset_id;

CREATE OR REPLACE VIEW depots.values AS
SELECT
  pv.depot_id,
  pv.tstamp,
  d.cash_start + SUM(pv.position_profit) AS value,
  d.cash_start - SUM(pv.running_commission + pv.running_expenses) AS cash,
  SUM(pv.position_profit) AS profit_from_start,
  SUM(pv.market_value) AS assets
FROM depots.position_values pv
JOIN depots.depots d ON pv.depot_id = d.id
GROUP BY pv.depot_id, pv.tstamp, d.cash_start
ORDER BY pv.depot_id, pv.tstamp;

CREATE INDEX IF NOT EXISTS idx_asset_prices_asset_tstamp 
  ON api.asset_prices (asset_id, tstamp DESC);

CREATE OR REPLACE VIEW depots.aggregated_values AS
WITH latest_per_depot AS (
  SELECT
    assets,
    depot_id,
    cash,
    profit_from_start,
    value as total,
    tstamp,
    NTH_VALUE(value, 2) OVER (PARTITION BY depot_id ORDER BY tstamp DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS prev_1d_total,
    NTH_VALUE(value, 23) OVER (PARTITION BY depot_id ORDER BY tstamp DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS prev_1m_total,
    NTH_VALUE(value, 253) OVER (ORDER BY tstamp DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS prev_1y_total,
    ROW_NUMBER() OVER (PARTITION BY depot_id ORDER BY tstamp DESC) AS rn
  FROM
    depots.values
)
SELECT
  assets,
  depot_id,
  cash,
  total,
  profit_from_start
  tstamp,
  prev_1d_total,
  prev_1m_total,
  prev_1y_total,
  -- Bonus: calculated differences if you want them
  total - prev_1d_total AS diff_1d,
  total - prev_1m_total AS diff_1m,
  total - prev_1y_total AS diff_1y,
  (total - prev_1d_total) / NULLIF (prev_1d_total, 0) * 100 AS rel_diff_1d,
  (total - prev_1m_total) / NULLIF (prev_1m_total, 0) * 100 AS rel_diff_1m,
  (total - prev_1y_total) / NULLIF (prev_1y_total, 0) * 100 AS rel_diff_1y
FROM
  latest_per_depot
WHERE
  rn = 1;

-- auth and roles
CREATE ROLE anon NOINHERIT NOLOGIN;

ALTER TABLE api.assets ENABLE ROW LEVEL SECURITY;

ALTER TABLE api.asset_prices ENABLE ROW LEVEL SECURITY;

ALTER ROLE anon SET search_path = api;

CREATE OR REPLACE VIEW depots.position_profits AS
WITH position_summary AS (
  SELECT
    depot_id,
    asset_id,
    SUM(amount) AS current_amount,
    SUM(
      CASE WHEN amount > 0 THEN
        amount * price + commission
      ELSE
        0
      END) AS total_invested,
    SUM(
      CASE WHEN amount < 0 THEN
        ABS(amount * price) - commission
      ELSE
        0
      END) AS total_sold
  FROM
    depots.transactions
  GROUP BY
    depot_id,
    asset_id
  HAVING
    SUM(amount) > 0 -- Only active positions
),
latest_prices AS (
  SELECT DISTINCT ON (asset_id)
    asset_id,
    CLOSE AS current_price
  FROM
    api.asset_prices
  WHERE close IS NOT NULL
  ORDER BY
    asset_id,
    tstamp DESC
)
SELECT
  ps.depot_id,
  ps.asset_id,
  a.symbol,
  a.name,
  a.asset_type,
  a.description,
  ps.current_amount,
  ps.total_invested,
  ps.total_sold,
  lp.current_price,
  ps.current_amount * lp.current_price AS market_value,
  -- Total profit
  ps.total_sold + (ps.current_amount * lp.current_price) - ps.total_invested AS total_profit
FROM
  position_summary ps
  JOIN api.assets a ON ps.asset_id = a.id
  LEFT JOIN latest_prices lp ON ps.asset_id = lp.asset_id;

-- CREATE UNIQUE INDEX idx_position_profits_unique ON depots.position_profits (depot_id, asset_id);

-- currently not done due to it requiring proper permission handling
-- CREATE OR REPLACE FUNCTION refresh_position_profits ()
--   RETURNS TRIGGER
--   AS $$
-- BEGIN
--   REFRESH MATERIALIZED VIEW CONCURRENTLY depots.position_profits;
--   RETURN NULL;
-- END;
-- $$
-- LANGUAGE plpgsql;

-- CREATE TRIGGER trigger_refresh_position_profits_transactions
--   AFTER INSERT OR UPDATE OR DELETE ON depots.transactions
--   FOR EACH STATEMENT
--   EXECUTE FUNCTION refresh_position_profits ();

-- CREATE TRIGGER trigger_refresh_position_profits_prices
--   AFTER INSERT OR UPDATE OR DELETE ON api.asset_prices
--   FOR EACH STATEMENT
--   EXECUTE FUNCTION refresh_position_profits ();

CREATE OR REPLACE VIEW depots.transactions_with_asset_position AS
SELECT
  dt.depot_id,
  dt.user_id,
  dt.asset_id,
  dt.amount,
  dt.price,
  dt.tstamp,
  dt.commission,
  dt.id,
  dp.symbol,
  dp.description,
  dp.asset_type,
  dp.current_amount,
  dp.total_invested,
  dp.total_sold,
  dp.total_profit,
  dp.current_price,
  dp.market_value
FROM depots.transactions AS dt
LEFT JOIN depots.position_profits AS dp ON dp.asset_id = dt.asset_id AND dp.depot_id = dt.depot_id;

CREATE TYPE SavingsPeriod AS ENUM (
  'annually',
  'monthly',
  'weekly',
  'daily' -- WHY NOT LOL
);

CREATE OR REPLACE FUNCTION depots.sp_to_per_month(period SavingsPeriod) 
RETURNS NUMERIC AS $$
BEGIN
  RETURN CASE period
    WHEN 'daily' THEN 365.0 / 12  -- 30.4167
    WHEN 'weekly' THEN 52.0 / 12  -- 4.3333
    WHEN 'monthly' THEN 1
    WHEN 'annually' THEN 1.0 / 12  -- 0.0833
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE TABLE IF NOT EXISTS depots.savings_plans (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  depot_id bigint NOT NULL,
  asset_id bigint NOT NULL,
  worth real NOT NULL,
  period SavingsPeriod NOT NULL,
  created timestamp NOT NULL,
  last_changed timestamp NOT NULL,
  last_executed date NOT NULL,
  created_by uuid NOT NULL,
  CONSTRAINT Savings_pkey PRIMARY KEY (asset_id, depot_id),
  CONSTRAINT Savings_depot_fkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id) ON DELETE CASCADE,
  CONSTRAINT Savings_stock_fkey FOREIGN KEY (asset_id) REFERENCES api.assets (id)
);


CREATE INDEX IF NOT EXISTS idx_savings_assets_depot ON depots.transactions (asset_id, depot_id);
CREATE INDEX IF NOT EXISTS idx_savings_asset ON depots.transactions (asset_id);
CREATE INDEX IF NOT EXISTS idx_savings_depot ON depots.transactions (depot_id);


-- Pooler
CREATE ROLE authenticator NOINHERIT LOGIN PASSWORD 'auth';

GRANT CONNECT ON DATABASE postgres TO authenticator;

GRANT anon TO authenticator;


GRANT USAGE ON SCHEMA depots TO authenticator;
GRANT SELECT ON depots.depots TO authenticator;
-- Service Rest
CREATE ROLE service_worker NOINHERIT BYPASSRLS LOGIN PASSWORD 'service';

GRANT CONNECT ON DATABASE postgres TO service_worker;

GRANT USAGE ON SCHEMA api TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON api.assets TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON api.asset_prices TO service_worker;

GRANT USAGE ON SEQUENCE api.assets_id_seq
  TO service_worker;

GRANT USAGE ON SCHEMA depots TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON depots.depots TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON depots.positions TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON depots.transactions TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON depots.transactions TO service_worker;

GRANT USAGE ON SEQUENCE depots.depots_id_seq
  TO service_worker;

GRANT USAGE ON SEQUENCE depots.positions_id_seq
  TO service_worker;

GRANT USAGE ON SEQUENCE depots.transactions_id_seq
  TO service_worker;

CREATE ROLE authenticated NOINHERIT NOLOGIN;

GRANT authenticated TO authenticator;


-- Enable pg_trgm extension if not already enabled
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS assets_symbol_trgm_idx ON api.assets USING GIN (symbol gin_trgm_ops);
CREATE INDEX IF NOT EXISTS assets_name_trgm_idx ON api.assets USING GIN (name gin_trgm_ops);
CREATE INDEX IF NOT EXISTS assets_description_trgm_idx ON api.assets USING GIN (description gin_trgm_ops);

-- Fuzzy search function
CREATE OR REPLACE FUNCTION api.search_assets(
  search_query text,
  asset_type_filter text DEFAULT NULL,
  result_limit integer DEFAULT 20
)
RETURNS TABLE (
  id bigint,
  symbol text,
  name text,
  description text,
  asset_type text,
  last_updated date,
  relevance_score numeric
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    a.id,
    a.symbol,
    a.name,
    a.description,
    a.asset_type::text,
    a.last_updated,
    -- Calculate relevance score (higher = better match)
    ROUND(
      CAST(
        -- Exact matches get highest score
        CASE WHEN LOWER(a.symbol) = LOWER(search_query) THEN 100
             WHEN LOWER(a.name) = LOWER(search_query) THEN 95
             ELSE 0 
        END +
        -- Starts-with matches get high score
        CASE WHEN LOWER(a.symbol) LIKE LOWER(search_query) || '%' THEN 50
             WHEN LOWER(a.name) LIKE LOWER(search_query) || '%' THEN 45
             ELSE 0
        END +
        -- Trigram similarity scores (0-1 range, multiply for weighting)
        similarity(a.symbol, search_query) * 40 +
        similarity(a.name, search_query) * 35 +
        COALESCE(similarity(a.description, search_query) * 15, 0) +
        -- Contains match bonus
        CASE WHEN LOWER(a.symbol) LIKE '%' || LOWER(search_query) || '%' THEN 10
             WHEN LOWER(a.name) LIKE '%' || LOWER(search_query) || '%' THEN 8
             ELSE 0
        END
      AS numeric), 2
    ) as relevance_score
  FROM api.assets a
  WHERE 
    -- Fuzzy match using trigram similarity OR contains
    (
      a.symbol % search_query OR
      a.name % search_query OR
      a.description % search_query OR
      LOWER(a.symbol) LIKE '%' || LOWER(search_query) || '%' OR
      LOWER(a.name) LIKE '%' || LOWER(search_query) || '%' OR
      LOWER(a.description) LIKE '%' || LOWER(search_query) || '%'
    )
    -- Optional asset type filter
    AND (asset_type_filter IS NULL OR a.asset_type::text = asset_type_filter)
  ORDER BY relevance_score DESC, a.name ASC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION api.search_assets(text, text, integer) TO anon, authenticated;


-- Set the commission configuration
ALTER DATABASE postgres SET config.commission = '1' ;
ALTER DATABASE postgres SET config.monthly_budget_start = '200' ;
